---
/**
 * Anime Page (Bangumi + Local, SSR/CSR safe)
 * - Node ç«¯æä¾› .cache/bangumi æŒä¹…ç¼“å­˜ï¼ˆå¯ç”¨ BANGUMI_DISABLE_DISK_CACHE=1 å…³é—­ï¼‰
 * - æœç´¢ä¸çŠ¶æ€ç­›é€‰åœ¨å‰ç«¯æ‰§è¡Œï¼›æ— é¢å¤–ä¾èµ–
 */

import { sidebarLayoutConfig, siteConfig } from "../config";
import localAnimeList from "../data/anime";
import I18nKey from "../i18n/i18nKey";
import { i18n } from "../i18n/translation";
import MainGridLayout from "../layouts/MainGridLayout.astro";

// i18n helpers with safe fallbacks
const T = {
  unknown: i18n((I18nKey as any).animeUnknown ?? "animeUnknown") || "Unknown",
  episodes: i18n((I18nKey as any).animeEpisodes ?? "animeEpisodes") || "episodes",
  paginationFirst:
    i18n((I18nKey as any).paginationFirst ?? "paginationFirst") || "First",
  paginationLast:
    i18n((I18nKey as any).paginationLast ?? "paginationLast") || "Last",
  searchAnimePlaceholder:
    i18n((I18nKey as any).searchAnimePlaceholder ?? "searchAnimePlaceholder") ||
    "Search by title, genre, studio...",
  totalLabel:
    i18n((I18nKey as any).animeTotalLabel ?? "animeTotalLabel") || "Total",
  avgRatingLabel:
    i18n((I18nKey as any).animeAvgRatingLabel ?? "animeAvgRatingLabel") ||
    "Average Rating",
  lastUpdatedLabel:
    i18n((I18nKey as any).animeLastUpdatedLabel ?? "animeLastUpdatedLabel") ||
    "Last Updated",
};

const episodesText = (n?: number) =>
  typeof n === "number" && n > 0 ? `${n} ${T.episodes}` : T.unknown;

// ç±»å‹
type LocalAnimeItem = (typeof localAnimeList)[number];
type AnimeStatus = "watching" | "completed" | "planned" | "onhold" | "dropped";
type AnimeItem = Omit<LocalAnimeItem, "status"> & {
  status: AnimeStatus;
  updatedAt?: string;
  startDate?: string;
  displayDate?: string;
  genre: string[];
  progress?: number;
  totalEpisodes?: number;
  episodes?: string;
};

// é¡µé¢å¼€å…³
if (!siteConfig.featurePages.anime) {
  return Astro.redirect("/404/");
}

// åŒä¾§è¾¹æ 
const isBothSidebarMode = sidebarLayoutConfig.position === "both";

// Bangumi API é…ç½®
const BANGUMI_USER_ID = siteConfig.bangumi?.userId || "your-user-id";
const BANGUMI_API_BASE = "https://api.bgm.tv";
const isValidUserId = !!BANGUMI_USER_ID && BANGUMI_USER_ID !== "your-user-id";

// æ¨¡å¼
const ANIME_MODE = siteConfig.anime?.mode || "bangumi";

// ä¸Šé™ä¸ç¼“å­˜ TTLï¼ˆå°æ—¶ï¼‰
type AnimeConfigExt = {
  mode?: "bangumi" | "local";
  maxItems?: number;
  cacheTtlHours?: number;
};
const animeCfg = (siteConfig.anime || {}) as AnimeConfigExt;
const MAX_ITEMS = Number(animeCfg.maxItems) > 0 ? Number(animeCfg.maxItems) : Infinity;
const CACHE_TTL_HOURS =
  Number(animeCfg.cacheTtlHours) >= 0 ? Number(animeCfg.cacheTtlHours) : 24;

// ç®€æ˜“ç£ç›˜æŒä¹…ç¼“å­˜ï¼ˆNode ç«¯æœ‰æ•ˆï¼‰ï¼›æ”¯æŒç¯å¢ƒå˜é‡ç¦ç”¨
type CacheEntry<T> = { ts: number; data: T };
const isNode =
  typeof process !== "undefined" && !!(process as any).versions?.node;
let fs: typeof import("fs/promises") | null = null;
let path: typeof import("path") | null = null;
if (isNode) {
  const fsMod = await import("fs/promises");
  const pathMod = await import("path");
  fs = fsMod;
  path = pathMod;
}

const cacheRoot =
  isNode && path ? path.resolve(process.cwd(), ".cache", "bangumi") : "";
const DISK_CACHE_DISABLED =
  isNode &&
  (process.env.BANGUMI_DISABLE_DISK_CACHE === "1" ||
    process.env.BANGUMI_DISABLE_DISK_CACHE === "true" ||
    CACHE_TTL_HOURS === 0);
const CAN_USE_DISK_CACHE = isNode && !DISK_CACHE_DISABLED;

async function diskCacheGet<T>(
  key: string,
  ttlHours: number,
): Promise<T | null> {
  if (!CAN_USE_DISK_CACHE || !fs || !path) return null;
  try {
    await fs.mkdir(cacheRoot, { recursive: true });
    const file = path.resolve(cacheRoot, `${key}.json`);
    const buf = await fs.readFile(file, { encoding: "utf8" as any });
    const jsonStr =
      typeof buf === "string"
        ? buf
        : new TextDecoder("utf-8").decode(buf as unknown as BufferSource);
    const parsed = JSON.parse(jsonStr) as CacheEntry<T>;
    const ageHours = (Date.now() - parsed.ts) / 3.6e6;
    if (ageHours <= ttlHours) return parsed.data;
    return null;
  } catch {
    return null;
  }
}
async function diskCacheSet<T>(key: string, data: T): Promise<void> {
  if (!CAN_USE_DISK_CACHE || !fs || !path) return;
  try {
    await fs.mkdir(cacheRoot, { recursive: true });
    const file = path.resolve(cacheRoot, `${key}.json`);
    const payload: CacheEntry<T> = { ts: Date.now(), data };
    await fs.writeFile(file, JSON.stringify(payload), { encoding: "utf8" });
  } catch {
    // ignore
  }
}

// fetch å¸¦é‡è¯•ä¸ 429/5xx é€€é¿
async function fetchWithRetry(
  url: string,
  init?: RequestInit,
  retries = 4,
  baseDelayMs = 400,
): Promise<Response> {
  for (let attempt = 0; attempt <= retries; attempt++) {
    const res = await fetch(url, init).catch(() => null);
    if (res && res.ok) return res as Response;

    const status = res?.status ?? 0;
    if (
      attempt < retries &&
      (status === 429 || (status >= 500 && status <= 599))
    ) {
      let delay = baseDelayMs * Math.pow(2, attempt);
      const retryAfter = res?.headers?.get("Retry-After");
      if (retryAfter) {
        const seconds = Number(retryAfter);
        if (!Number.isNaN(seconds) && seconds > 0) delay = seconds * 1000;
      }
      delay += Math.floor(Math.random() * 200); // jitter
      await new Promise((r) => setTimeout(r, delay));
      continue;
    }
    if (res) return res;
    throw new Error("Network error");
  }
  throw new Error("fetchWithRetry exhausted");
}

// å…¼å®¹åœ°ä» infobox/å¤šç§æ¥æºæå–é”®å€¼
function pickFirstUsefulValue(v: any): string | undefined {
  if (v == null) return undefined;
  if (typeof v === "string") return v.trim() || undefined;
  if (Array.isArray(v)) {
    for (const it of v) {
      const got = pickFirstUsefulValue(it);
      if (got) return got;
    }
    return undefined;
  }
  if (typeof v === "object") {
    if (typeof v.v === "string") return v.v.trim() || undefined;
    if (typeof v.value === "string") return v.value.trim() || undefined;
  }
  return undefined;
}

// ä» subject.infobox æå–å¼€æ’­æ—¥æœŸ
function getStartDateFromInfobox(subject: any): string | undefined {
  const keys = [
    "æ”¾é€å¼€å§‹",
    "æ”¾é€é–‹å§‹",
    "é¦–æ’­",
    "é¦–æ˜ ",
    "é¦–æ’­æ—¥æœŸ",
    "ä¸Šæ˜ æ—¥æœŸ",
    "ä¸Šæ˜ å¹´åº¦",
    "ä¸Šæ˜ æ—¶é—´",
    "å‘å”®æ—¥",
    "é–‹å§‹",
    "é–‹å§‹æ—¥",
    "å¼€å§‹",
    "é–‹å§‹æ™‚é–“",
    "å¼€å§‹æ—¶é—´",
    "å¼€æ’­",
    "é¦–æ’­æ—¶é—´",
  ];
  const infobox = subject?.infobox;
  if (!Array.isArray(infobox)) return undefined;

  for (const k of keys) {
    const entry = infobox.find((x: any) => x?.key === k);
    if (!entry) continue;
    const v = pickFirstUsefulValue(entry?.value);
    if (v) return v;
  }
  return undefined;
}

// ä» subject.infobox æå–åˆ¶ä½œå…¬å¸
function getStudioFromInfobox(subject: any): string | undefined {
  const keys = [
    "åŠ¨ç”»åˆ¶ä½œ",
    "è£½ä½œ",
    "åˆ¶ä½œ",
    "åŠ¨ç”»å…¬å¸",
    "Studio",
    "åˆ¶ä½œå…¬å¸",
    "åˆ¶ä½œã‚¹ã‚¿ã‚¸ã‚ª",
  ];
  const infobox = subject?.infobox;
  if (!Array.isArray(infobox)) return undefined;

  for (const k of keys) {
    const entry = infobox.find((x: any) => x?.key === k);
    if (!entry) continue;
    const v = pickFirstUsefulValue(entry?.value);
    if (v) return v;
  }
  return undefined;
}

// å±•ç¤ºæ—¥æœŸï¼šä¼˜å…ˆ YYYY-MM-DDï¼Œå…¶æ¬¡ YYYY-MMï¼Œå†æ¬¡ YYYY
function toDisplayYearOrYearMonth(input?: string): string {
  if (!input) return T.unknown;
  const s = input.trim();
  const ymd = /^(\d{4})-(\d{2})-(\d{2})$/;
  const ym = /^(\d{4})-(\d{2})$/;
  const y = /^(\d{4})$/;
  if (ymd.test(s)) return s;
  if (ym.test(s)) return s;
  if (y.test(s)) return s;

  const mYMD = s.match(/(\d{4})[-/å¹´](\d{1,2})[-/æœˆ](\d{1,2})/);
  if (mYMD) {
    const year = mYMD[1];
    const mm = String(mYMD[2]).padStart(2, "0");
    const dd = String(mYMD[3]).padStart(2, "0");
    return `${year}-${mm}-${dd}`;
  }
  const mYM = s.match(/(\d{4})[-/å¹´](\d{1,2})/);
  if (mYM) {
    const year = mYM[1];
    const mm = String(mYM[2]).padStart(2, "0");
    return `${year}-${mm}`;
  }
  const mY = s.match(/(\d{4})/);
  if (mY) return mY[1];

  return T.unknown;
}

// å®‰å…¨è§£ææ—¥æœŸä¸ºæ—¶é—´æˆ³
function toTime(input?: string) {
  if (!input) return 0;
  const s = input.trim();
  if (/^\d{4}$/.test(s)) return Date.parse(`${s}-01-01T00:00:00Z`);
  if (/^\d{4}-\d{2}$/.test(s)) return Date.parse(`${s}-01T00:00:00Z`);
  const t = Date.parse(s);
  return Number.isNaN(t) ? 0 : t;
}

// äººå‘˜æ¥å£
async function fetchSubjectPersonsRaw(subjectId: number) {
  const res = await fetchWithRetry(
    `${BANGUMI_API_BASE}/v0/subjects/${subjectId}/persons`,
  );
  if (!res.ok) return [];
  const ct = res.headers.get("content-type") || "";
  if (!ct.includes("application/json")) return [];
  const data = await res.json().catch(() => []);
  return Array.isArray(data) ? data : [];
}
async function fetchSubjectDetailRaw(subjectId: number) {
  const res = await fetchWithRetry(
    `${BANGUMI_API_BASE}/v0/subjects/${subjectId}`,
  );
  if (!res.ok)
    throw new Error(`Bangumi subject ${subjectId} error: ${res.status}`);
  return await res.json();
}

// ç®€å•å†…å­˜ç¼“å­˜ + ç£ç›˜ç¼“å­˜
const subjectDetailCache = new Map<number, any>();
const subjectPersonsCache = new Map<number, any[]>();

async function fetchSubjectDetailCached(id: number) {
  if (subjectDetailCache.has(id)) return subjectDetailCache.get(id);
  const diskKey = `subject-${id}`;
  const disk = await diskCacheGet<any>(diskKey, CACHE_TTL_HOURS);
  if (disk) {
    subjectDetailCache.set(id, disk);
    return disk;
  }
  const d = await fetchSubjectDetailRaw(id).catch((e) => {
    console.error(`Error fetching subject ${id} detail:`, e);
    return null;
  });
  subjectDetailCache.set(id, d);
  if (d) await diskCacheSet(diskKey, d);
  return d;
}
async function fetchSubjectPersonsCached(id: number) {
  if (subjectPersonsCache.has(id)) return subjectPersonsCache.get(id);
  const diskKey = `persons-${id}`;
  const disk = await diskCacheGet<any[]>(diskKey, CACHE_TTL_HOURS);
  if (disk) {
    subjectPersonsCache.set(id, disk);
    return disk;
  }
  const p = await fetchSubjectPersonsRaw(id).catch((e) => {
    console.error(`Error fetching subject ${id} persons:`, e);
    return [];
  });
  subjectPersonsCache.set(id, p);
  if (p?.length) await diskCacheSet(diskKey, p);
  return p;
}

// å¹¶å‘é™åˆ¶
async function mapWithConcurrency<T, R>(
  items: T[],
  limit: number,
  fn: (item: T, idx: number) => Promise<R>,
): Promise<R[]> {
  const results: R[] = new Array(items.length);
  let i = 0;
  const runners = new Array(Math.min(limit, items.length)).fill(0).map(async () => {
    while (true) {
      const idx = i++;
      if (idx >= items.length) return;
      results[idx] = await fn(items[idx], idx);
    }
  });
  await Promise.all(runners);
  return results;
}

// è·å– Bangumi æ”¶è—åˆ—è¡¨ï¼ˆåˆ†é¡µæŠ“å– + å¯é€‰ä¸Šé™ + ç£ç›˜ç¼“å­˜ï¼‰
async function fetchBangumiCollection(
  userId: string,
  subjectType: number,
  type: number,
) {
  const cacheKey = `collection-${userId}-${subjectType}-${type}`;
  const cached = await diskCacheGet<{ data: any[] }>(cacheKey, CACHE_TTL_HOURS);
  if (cached && cached.data?.length) return cached;

  try {
    let allData: any[] = [];
    let offset = 0;
    const pageLimit = 50;

    while (true) {
      const url = `${BANGUMI_API_BASE}/v0/users/${userId}/collections?subject_type=${subjectType}&type=${type}&limit=${pageLimit}&offset=${offset}`;
      const response = await fetchWithRetry(url);
      if (!response.ok) throw new Error(`Bangumi API error: ${response.status}`);

      const data = await response.json();
      const batch = data.data || [];
      if (batch.length > 0) allData = [...allData, ...batch];

      if (allData.length >= MAX_ITEMS) {
        allData = allData.slice(0, MAX_ITEMS as number);
        break;
      }

      const hasMore = batch.length === pageLimit;
      if (!hasMore) break;
      offset += pageLimit;

      await new Promise((resolve) => setTimeout(resolve, 100)); // èŠ‚æµ
    }

    const payload = { data: allData };
    await diskCacheSet(cacheKey, payload);
    return payload;
  } catch (error) {
    console.error("Error fetching Bangumi data:", error);
    return null;
  }
}

// è½¬æ¢ä¸ºé¡µé¢æ•°æ®
async function processBangumiData(
  data: any,
  status: AnimeStatus,
): Promise<AnimeItem[]> {
  if (!data || !data.data) return [];
  const items: any[] = data.data;

  const detailedItems = await mapWithConcurrency(
    items,
    6,
    async (item: any) => {
      const subjectId = item.subject_id;
      const subject = item.subject || {};

      // detail æ€»æ˜¯æ‹¿ä¸€æ¬¡ï¼ˆæœ‰ç¼“å­˜/å¹¶å‘é™åˆ¶ï¼‰
      const detail = await fetchSubjectDetailCached(subjectId);

      // èµ·å§‹æ—¥æœŸï¼šä¼˜å…ˆ subject.dateï¼ˆè‹¥é Unknownï¼‰ï¼Œå¦åˆ™ detail.date æˆ– detail.infobox
      const rawDate = (subject?.date || "").trim();
      const isUnknown =
        !rawDate || /^unknown$/i.test(rawDate) || rawDate === "0000-00-00";
      const detailDate = (detail?.date || "").trim();
      const infoboxStart = getStartDateFromInfobox(detail);
      const startDate = (isUnknown ? (detailDate || infoboxStart || "") : rawDate) || undefined;

      const displayDate = toDisplayYearOrYearMonth(startDate);

      // è¯„åˆ†/è¿›åº¦
      const rating =
        typeof item.rate === "number" ? Number(item.rate.toFixed(1)) : 0;
      const progress = item.ep_status || 0;
      const totalEpisodes =
        typeof subject?.eps === "number" && subject?.eps > 0
          ? subject.eps
          : progress;

      // Studioï¼šä¼˜å…ˆ detail.infoboxï¼Œå…¶æ¬¡ persons
      let studio = getStudioFromInfobox(detail) || T.unknown;
      if (!studio || studio === T.unknown) {
        const subjectPersons = await fetchSubjectPersonsCached(subjectId);
        if (Array.isArray(subjectPersons)) {
          const priorities = ["åŠ¨ç”»åˆ¶ä½œ", "è£½ä½œ", "åˆ¶ä½œ"];
          for (const relation of priorities) {
            const match = subjectPersons.find(
              (person) => person.relation === relation,
            );
            if (match?.name) {
              studio = match.name;
              break;
            }
          }
        }
        if (!studio) studio = T.unknown;
      }

      // æ ‡ç­¾
      const genre: string[] = Array.isArray(subject?.tags)
        ? subject.tags
            .slice(0, 4)
            .map((t: any) => {
              if (typeof t === "string") return t.trim();
              if (t && typeof t.name === "string") return t.name.trim();
              return "";
            })
            .filter(Boolean)
        : [];

      const updatedAt: string | undefined =
        item.updated_at ||
        item.comment_updated_at ||
        item.created_at ||
        subject?.date ||
        undefined;

      const cover = subject?.images?.medium || "/assets/anime/default.webp";
      const title = subject?.name_cn || subject?.name || T.unknown;
      const description =
        (detail?.summary ||
          subject?.short_summary ||
          subject?.name_cn ||
          "")?.trimStart?.() || "";

      return {
        title,
        status,
        rating,
        cover,
        description,
        year: displayDate,
        displayDate,
        studio,
        link: `https://bgm.tv/subject/${subjectId}`,
        progress,
        totalEpisodes,
        startDate: startDate || "",
        endDate: "",
        updatedAt,
        genre,
        episodes: episodesText(totalEpisodes),
      } as AnimeItem;
    },
  );

  return detailedItems as AnimeItem[];
}

// æ ¹æ®æ¨¡å¼è·å–ç•ªå‰§åˆ—è¡¨
let animeList: AnimeItem[] = [];
if (ANIME_MODE === "local") {
  animeList = (localAnimeList as AnimeItem[]).map((a) => {
    const linkId = (a as any).id || (a as any).subjectId;
    return {
      ...a,
      displayDate: toDisplayYearOrYearMonth(a.startDate || (a as any).year),
      genre: Array.isArray((a as any).genre) ? (a as any).genre : [],
      episodes: episodesText((a as any).totalEpisodes),
      link: linkId ? `https://bgm.tv/subject/${linkId}` : "#",
    };
  });
} else if (!isValidUserId) {
  animeList = [];
} else {
  const [watchingData, plannedData, completedData, onHoldData, droppedData] =
    await Promise.all([
      fetchBangumiCollection(BANGUMI_USER_ID, 2, 3),
      fetchBangumiCollection(BANGUMI_USER_ID, 2, 1),
      fetchBangumiCollection(BANGUMI_USER_ID, 2, 2),
      fetchBangumiCollection(BANGUMI_USER_ID, 2, 4),
      fetchBangumiCollection(BANGUMI_USER_ID, 2, 5),
    ]);

  const watchingList = watchingData
    ? await processBangumiData(watchingData, "watching")
    : [];
  const plannedList = plannedData
    ? await processBangumiData(plannedData, "planned")
    : [];
  const completedList = completedData
    ? await processBangumiData(completedData, "completed")
    : [];
  const onHoldList = onHoldData
    ? await processBangumiData(onHoldData, "onhold")
    : [];
  const droppedList = droppedData
    ? await processBangumiData(droppedData, "dropped")
    : [];

  animeList = [
    ...watchingList,
    ...plannedList,
    ...completedList,
    ...onHoldList,
    ...droppedList,
  ];
  if (Number.isFinite(MAX_ITEMS)) {
    animeList = animeList.slice(0, MAX_ITEMS as number);
  }
}

// è·å–çŠ¶æ€çš„ç¿»è¯‘æ–‡æœ¬å’Œæ ·å¼
function getStatusInfo(status: string) {
  switch (status) {
    case "watching":
      return {
        text: i18n(I18nKey.animeStatusWatching),
        class:
          "bg-green-100 text-green-700 dark:bg-green-900/30 dark:text-green-300",
        icon: "â–¶",
      };
    case "completed":
      return {
        text: i18n(I18nKey.animeStatusCompleted),
        class:
          "bg-blue-100 text-blue-700 dark:bg-blue-900/30 dark:text-blue-300",
        icon: "âœ“",
      };
    case "planned":
      return {
        text: i18n(I18nKey.animeStatusPlanned),
        class:
          "bg-amber-100 text-amber-700 dark:bg-amber-900/30 dark:text-amber-300",
        icon: "â°",
      };
    case "onhold":
      return {
        text: i18n(I18nKey.animeStatusOnHold),
        class:
          "bg-purple-100 text-purple-700 dark:bg-purple-900/30 dark:text-purple-300",
        icon: "â¸",
      };
    case "dropped":
      return {
        text: i18n(I18nKey.animeStatusDropped),
        class:
          "bg-red-100 text-red-700 dark:bg-red-900/30 dark:text-red-300",
        icon: "âœ—",
      };
    default:
      return {
        text: status,
        class: "bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300",
        icon: "?",
      };
  }
}

// ç»Ÿè®¡
const stats = {
  total: animeList.length,
  watching: animeList.filter((anime) => anime.status === "watching").length,
  completed: animeList.filter((anime) => anime.status === "completed").length,
  avgRating: (() => {
    const ratedAnime = animeList.filter((anime) => (anime.rating || 0) > 0);
    if (ratedAnime.length === 0) return "0.0";
    return (
      ratedAnime.reduce((sum, anime) => sum + (anime.rating || 0), 0) /
      ratedAnime.length
    ).toFixed(1);
  })(),
};

// æœ€åæ›´æ–°æ—¶é—´
const lastUpdated = new Date().toLocaleString("zh-CN", {
  year: "numeric",
  month: "2-digit",
  day: "2-digit",
  hour: "2-digit",
  minute: "2-digit",
  hour12: false,
  timeZone: "Asia/Shanghai",
});

// æ’åº
const sortedAnimeList = [...animeList].sort((a, b) => {
  const aTime = toTime(a.updatedAt) || toTime(a.startDate) || toTime(a.displayDate);
  const bTime = toTime(b.updatedAt) || toTime(b.startDate) || toTime(b.displayDate);
  return bTime - aTime;
});

// æ ‡è®°ä¸ºå·²è¯»é¿å…æœªä½¿ç”¨å‘Šè­¦
void animeList;
void stats;
void lastUpdated;
void sortedAnimeList;
void isBothSidebarMode;
---

<MainGridLayout title={i18n(I18nKey.anime)} description={i18n(I18nKey.animeSubtitle)}>
  <div class="flex w-full rounded-[var(--radius-large)] overflow-hidden relative min-h-32">
    <div class="card-base z-10 px-9 py-6 relative w-full">
      <div class="relative w-full mb-8">
        <div class="mb-6">
          <h1 class="text-4xl font-bold text-black/90 dark:text-white/90 mb-2 relative
                    before:w-1 before:h-8 before:rounded-md before:bg-[var(--primary)]
                    before:absolute before:top-1/2 before:-translate-y-1/2 before:-left-4">
            {i18n(I18nKey.animeTitle)}
          </h1>
          <p class="text-black/75 dark:text-white/75">{i18n(I18nKey.animeSubtitle)}</p>
        </div>
        
        <div class="stats-container grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
          <div class="stat-card bg-[var(--card-bg)] border border-[var(--line-divider)] rounded-[var(--radius-large)] p-4 flex flex-col items-center justify-center">
            <div class="text-xs text-black/60 dark:text-white/60 mb-1">{T.totalLabel}</div>
            <div class="text-2xl font-bold text-[var(--primary)]">{stats.total}</div>
          </div>
          <div class="stat-card bg-[var(--card-bg)] border border-[var(--line-divider)] rounded-[var(--radius-large)] p-4 flex flex-col items-center justify-center">
            <div class="text-xs text-black/60 dark:text-white/60 mb-1">{T.avgRatingLabel}</div>
            <div class="text-2xl font-bold text-blue-500">{stats.avgRating}</div>
          </div>
          <div class="stat-card bg-[var(--card-bg)] border border-[var(--line-divider)] rounded-[var(--radius-large)] p-4 flex flex-col items-center justify-center">
            <div class="text-xs text-black/60 dark:text-white/60 mb-1">{T.lastUpdatedLabel}</div>
            <div class="text-sm font-medium text-black/80 dark:text-white/80">{lastUpdated}</div>
          </div>
        </div>
        
        <div class="search-container mb-6">
          <div class="relative">
            <input 
              type="text" 
              id="search-input" 
              placeholder={T.searchAnimePlaceholder}
              class="w-full px-4 py-3 pl-12 rounded-[var(--radius-large)] border border-[var(--line-divider)] bg-[var(--card-bg)] text-[var(--text-body)] focus:outline-none focus:ring-2 focus:ring-[var(--primary)] focus:border-transparent"
              aria-label={T.searchAnimePlaceholder}
            />
            <div class="absolute left-4 top-1/2 transform -translate-y-1/2 text-[var(--text-secondary)]">
              <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
              </svg>
            </div>
          </div>
        </div>
        
        <div class="mb-6">
          <div class="filter-container flex flex-wrap gap-2" role="group" aria-label="Anime filters">
            <button class="filter-tag active" data-status="all" role="button" aria-pressed="true">
              {i18n(I18nKey.animeFilterAll)} 
              <span class="ml-1 bg-[var(--primary)] text-white text-xs rounded-full px-2 py-0.5">({animeList.length})</span>
            </button>
            <button class="filter-tag" data-status="watching" role="button" aria-pressed="false">
              {i18n(I18nKey.animeStatusWatching)} 
              <span class="ml-1 bg-green-500 text-white text-xs rounded-full px-2 py-0.5">({animeList.filter(a => a.status === 'watching').length})</span>
            </button>
            <button class="filter-tag" data-status="planned" role="button" aria-pressed="false">
              {i18n(I18nKey.animeStatusPlanned)} 
              <span class="ml-1 bg-amber-500 text-white text-xs rounded-full px-2 py-0.5">({animeList.filter(a => a.status === 'planned').length})</span>
            </button>
            <button class="filter-tag" data-status="completed" role="button" aria-pressed="false">
              {i18n(I18nKey.animeStatusCompleted)} 
              <span class="ml-1 bg-blue-500 text-white text-xs rounded-full px-2 py-0.5">({animeList.filter(a => a.status === 'completed').length})</span>
            </button>
            {ANIME_MODE === 'bangumi' && (
              <>
                <button class="filter-tag" data-status="onhold" role="button" aria-pressed="false">
                  {i18n(I18nKey.animeStatusOnHold)} 
                  <span class="ml-1 bg-purple-500 text-white text-xs rounded-full px-2 py-0.5">({animeList.filter(a => a.status === 'onhold').length})</span>
                </button>
                <button class="filter-tag" data-status="dropped" role="button" aria-pressed="false">
                  {i18n(I18nKey.animeStatusDropped)} 
                  <span class="ml-1 bg-red-500 text-white text-xs rounded-full px-2 py-0.5">({animeList.filter(a => a.status === 'dropped').length})</span>
                </button>
              </>
            )}
          </div>
        </div>
      </div>

      <div class="mb-8">
        {ANIME_MODE !== 'local' && !isValidUserId ? (
          <div class="text-center py-12">
            <div class="text-5xl mb-4" aria-hidden="true">ğŸ˜¢</div>
            <h3 class="text-xl font-medium text-black/80 dark:text-white/80 mb-2">
              {i18n(I18nKey.animeEmpty)}
            </h3>
            <p class="text-black/60 dark:text-white/60">
              è¯·åœ¨ src/config.ts æ–‡ä»¶ä¸­è®¾ç½®ä½ çš„ Bangumi ç”¨æˆ·ID
            </p>
          </div>
        ) : animeList.length > 0 ? (
          <div id="anime-list-container" class={`anime-grid-container gap-4 md:gap-6 list-mode ${isBothSidebarMode ? "both-sidebar" : "single-sidebar"}`}>
            {sortedAnimeList.map((anime) => {
              const statusInfo = getStatusInfo(anime.status);
              const total = typeof anime.totalEpisodes === "number" ? anime.totalEpisodes : 0;
              const progress = typeof anime.progress === "number" ? anime.progress : 0;
              const progressPercent = total > 0 ? Math.min(100, Math.round((progress / total) * 100)) : 0;
              const keywords = [
                anime.title || "",
                anime.studio || "",
                Array.isArray(anime.genre) ? anime.genre.join(" ") : "",
                anime.displayDate || "",
              ].join(" ").toLowerCase();

              return (
                <article class="anime-card bg-[var(--card-bg)] border border-[var(--line-divider)] rounded-[var(--radius-large)] p-3 hover:border-[var(--primary)]/40 transition-colors"
                         data-status={anime.status}
                         data-keywords={keywords}>
                  <a href={anime.link} target="_blank" rel="noopener noreferrer" class="block relative aspect-[3/4] overflow-hidden rounded-lg">
                    <img src={anime.cover} alt={anime.title} loading="lazy"
                      class="w-full h-full object-cover transition-transform duration-300 hover:scale-105" />
                    <span class={`absolute top-2 left-2 px-2 py-1 rounded-md text-xs font-medium ${statusInfo.class}`} title={statusInfo.text}>
                      <span aria-hidden="true">{statusInfo.icon}</span>
                      <span class="ml-1">{statusInfo.text}</span>
                    </span>
                  </a>

                  <div class="mt-3">
                    <a href={anime.link} target="_blank" rel="noopener noreferrer"
                       class="line-clamp-2 font-semibold text-black/90 dark:text-white/90 hover:text-[var(--primary)]">
                      {anime.title}
                    </a>
                    <div class="mt-1 text-xs text-black/60 dark:text-white/60">
                      <span>{anime.displayDate}</span>
                      <span class="mx-1">Â·</span>
                      <span>{anime.studio || T.unknown}</span>
                    </div>

                    <div class="mt-3">
                      <div class="flex items-center justify-between text-xs text-black/70 dark:text-white/70 mb-1">
                        <div>{episodesText(total)}</div>
                        <div class="font-medium">{progress}/{total}</div>
                      </div>
                      <div class="h-2 bg-black/10 dark:bg-white/10 rounded-full overflow-hidden" aria-label="progress">
                        <div class="h-full bg-[var(--primary)]" style={{ width: `${progressPercent}%` }}></div>
                      </div>
                    </div>

                    <div class="mt-3 flex items-center text-xs text-amber-500">
                      <svg class="w-4 h-4" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                        <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.802 2.036a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.802-2.036a1 1 0 00-1.176 0l-2.802 2.036c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.88 8.72c-.783-.57-.38-1.81.588-1.81H6.93a1 1 0 00.95-.69l1.07-3.292z"/>
                      </svg>
                      <span class="ml-1">{anime.rating || 0}</span>
                    </div>

                    {Array.isArray(anime.genre) && anime.genre.length > 0 && (
                      <div class="mt-3 flex flex-wrap gap-1">
                        {anime.genre.map((g) => (
                          <span class="px-2 py-0.5 rounded-full text-xs bg-black/5 dark:bg-white/10 text-black/70 dark:text-white/70">{g}</span>
                        ))}
                      </div>
                    )}

                    {anime.updatedAt && (
                      <div class="mt-3 text-[10px] text-black/50 dark:text-white/50">
                        æ›´æ–°: {new Date(anime.updatedAt).toLocaleString("zh-CN", { timeZone: "Asia/Shanghai" })}
                      </div>
                    )}
                  </div>
                </article>
              );
            })}
          </div>
        ) : (
          <div class="text-center py-12">
            <div class="text-5xl mb-4" aria-hidden="true">ğŸ—‚ï¸</div>
            <h3 class="text-xl font-medium text-black/80 dark:text-white/80 mb-2">
              {i18n(I18nKey.animeEmpty)}
            </h3>
            <p class="text-black/60 dark:text-white/60">
              {ANIME_MODE === 'local' ? 'è¯·åœ¨ data/anime.ts é…ç½®ä½ çš„æœ¬åœ°ç•ªå‰§æ•°æ®' : 'æœªè·å–åˆ° Bangumi æ•°æ®'}
            </p>
          </div>
        )}
      </div>
    </div>
  </div>

  <script is:inline>
    // è½»é‡å‰ç«¯ç­›é€‰/æœç´¢é€»è¾‘ï¼ˆæ— ä¾èµ–ï¼‰
    const input = document.getElementById('search-input');
    const container = document.getElementById('anime-list-container');
    const cards = Array.from(container?.querySelectorAll('[data-status]') || []);
    const buttons = Array.from(document.querySelectorAll('.filter-tag'));
    let activeStatus = 'all';

    function applyFilters() {
      const q = (input?.value || '').trim().toLowerCase();
      for (const el of cards) {
        const status = el.getAttribute('data-status') || '';
        const keys = (el.getAttribute('data-keywords') || '').toLowerCase();
        const matchStatus = activeStatus === 'all' || status === activeStatus;
        const matchQuery = !q || keys.includes(q);
        el.classList.toggle('hidden', !(matchStatus && matchQuery));
      }
    }

    buttons.forEach((btn) => {
      btn.addEventListener('click', () => {
        const s = btn.getAttribute('data-status') || 'all';
        activeStatus = s;
        buttons.forEach((b) => {
          const isActive = b === btn;
          b.classList.toggle('active', isActive);
          b.setAttribute('aria-pressed', isActive ? 'true' : 'false');
        });
        applyFilters();
      });
    });

    input?.addEventListener('input', () => applyFilters());
  </script>

  <style>
    /* è½»é‡æ ·å¼å¢å¼ºï¼ˆTailwind ä¹‹å¤–ï¼‰ */
    .filter-tag {
      @apply px-3 py-1.5 rounded-full border text-sm transition-colors;
      border-color: var(--line-divider);
      background: var(--card-bg);
      color: var(--text-secondary);
    }
    .filter-tag.active {
      border-color: color-mix(in oklab, var(--primary) 55%, transparent);
      color: var(--primary);
      box-shadow: 0 0 0 2px color-mix(in oklab, var(--primary) 15%, transparent) inset;
    }

    .anime-grid-container {
      display: grid;
      grid-template-columns: repeat(1, minmax(0, 1fr));
    }
    @media (min-width: 640px) {
      .anime-grid-container { grid-template-columns: repeat(2, minmax(0, 1fr)); }
    }
    @media (min-width: 768px) {
      .anime-grid-container { grid-template-columns: repeat(3, minmax(0, 1fr)); }
    }
    @media (min-width: 1024px) {
      .anime-grid-container.single-sidebar { grid-template-columns: repeat(4, minmax(0, 1fr)); }
      .anime-grid-container.both-sidebar   { grid-template-columns: repeat(3, minmax(0, 1fr)); }
    }
    @media (min-width: 1280px) {
      .anime-grid-container.single-sidebar { grid-template-columns: repeat(5, minmax(0, 1fr)); }
      .anime-grid-container.both-sidebar   { grid-template-columns: repeat(4, minmax(0, 1fr)); }
    }
  </style>
</MainGridLayout>
