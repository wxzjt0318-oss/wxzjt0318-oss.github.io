---
import ImageWrapper from "../components/misc/ImageWrapper.astro";
import { sidebarLayoutConfig, siteConfig } from "../config";
import localAnimeList from "../data/anime";
import I18nKey from "../i18n/i18nKey";
import { i18n } from "../i18n/translation";
import MainGridLayout from "../layouts/MainGridLayout.astro";

// æ‰©å±•çŠ¶æ€ç±»å‹ï¼ŒåŒ…å« onholdã€droppedï¼Œè§£å†³ TS æ¯”è¾ƒé”™è¯¯
type LocalAnimeItem = (typeof localAnimeList)[number];
type AnimeStatus = 'watching' | 'completed' | 'planned' | 'onhold' | 'dropped';
type AnimeItem = Omit<LocalAnimeItem, 'status'> & { status: AnimeStatus };

// æ£€æŸ¥ç•ªå‰§é¡µé¢æ˜¯å¦å¯ç”¨
if (!siteConfig.featurePages.anime) {
    return Astro.redirect("/404/");
}

// æ£€æŸ¥ç•ªå‰§é¡µé¢æ˜¯å¦å¯ç”¨
if (!siteConfig.featurePages.anime) {
    return Astro.redirect("/404/");
}

// æ£€æŸ¥æ˜¯å¦ä¸ºåŒä¾§è¾¹æ æ¨¡å¼
const isBothSidebarMode = sidebarLayoutConfig.position === "both";

// Bangumi APIé…ç½®
const BANGUMI_USER_ID = siteConfig.bangumi?.userId || "your-user-id"; // ç”¨æˆ·ID
const BANGUMI_API_BASE = "https://api.bgm.tv";

// è·å–ç•ªå‰§æ•°æ®æ¨¡å¼(ä¸éœ€è¦æ›´æ”¹ï¼Œè¯·åœ¨ä¸»é…ç½®src/config.tsä¸­ä¿®æ”¹)
const ANIME_MODE = siteConfig.anime?.mode || "bangumi";

// è·å–å•ä¸ªæ¡ç›®ç›¸å…³äººå‘˜ä¿¡æ¯
async function fetchSubjectPersons(subjectId: number) {
    try {
        const response = await fetch(
            `${BANGUMI_API_BASE}/v0/subjects/${subjectId}/persons`,
        );
        const data = await response.json();
        return Array.isArray(data) ? data : [];
    } catch (error) {
        console.error(`Error fetching subject ${subjectId} persons:`, error);
        return [];
    }
}

// è·å–Bangumiæ”¶è—åˆ—è¡¨
async function fetchBangumiCollection(
    userId: string,
    subjectType: number,
    type: number,
) {
    try {
        let allData: any[] = [];
        let offset = 0;
        const limit = 50; // æ¯é¡µè·å–çš„æ•°é‡
        let hasMore = true;

        // å¾ªç¯è·å–æ‰€æœ‰æ•°æ®
        while (hasMore) {
            const response = await fetch(
                `${BANGUMI_API_BASE}/v0/users/${userId}/collections?subject_type=${subjectType}&type=${type}&limit=${limit}&offset=${offset}`,
            );
            if (!response.ok) {
                throw new Error(`Bangumi API error: ${response.status}`);
            }
            const data = await response.json();

            // æ·»åŠ å½“å‰é¡µæ•°æ®åˆ°æ€»æ•°æ®ä¸­
            if (data.data && data.data.length > 0) {
                allData = [...allData, ...data.data];
            }
            if (!data.data || data.data.length < limit) {
                hasMore = false;
            } else {
                offset += limit;
            }
            // é˜²æ­¢è¯·æ±‚è¿‡äºé¢‘ç¹
            await new Promise((resolve) => setTimeout(resolve, 100));
        }
        return { data: allData };
    } catch (error) {
        console.error("Error fetching Bangumi data:", error);
        return null;
    }
}

// è·å–Bangumiæ•°æ®è½¬æ¢ä¸ºé¡µé¢æ‰€éœ€æ ¼å¼
async function processBangumiData(data: any, status: AnimeStatus): Promise<AnimeItem[]> {
    if (!data || !data.data) return [];

    // ä¸ºæ¯ä¸ªæ¡ç›®è·å–è¯¦ç»†ä¿¡æ¯
    const detailedItems = await Promise.all(
        data.data.map(async (item: any) => {
            // è·å–ç›¸å…³äººå‘˜ä¿¡æ¯
            const subjectPersons = await fetchSubjectPersons(item.subject_id);
            // è·å–å¹´ä»½ä¿¡æ¯
            const year = item.subject?.date || "Unknown";
            // è·å–è¯„åˆ†
            const rating = item.rate ? Number.parseFloat(item.rate.toFixed(1)) : 0;
            // è·å–è¿›åº¦ä¿¡æ¯
            const progress = item.ep_status || 0;
            const totalEpisodes = item.subject?.eps || progress;
            // ä»ç›¸å…³äººå‘˜ä¸­è·å–åˆ¶ä½œæ–¹ä¿¡æ¯
            let studio = "Unknown";
            if (Array.isArray(subjectPersons)) {
                // å®šä¹‰ç­›é€‰ä¼˜å…ˆçº§é¡ºåº
                const priorities = ["åŠ¨ç”»åˆ¶ä½œ", "è£½ä½œ", "åˆ¶ä½œ"];
                for (const relation of priorities) {
                    const match = subjectPersons.find(
                        (person) => person.relation === relation,
                    );
                    if (match?.name) {
                        studio = match.name;
                        break;
                    }
                }
            }

            return {
                title: item.subject?.name_cn || item.subject?.name || "Unknown Title",
                status: status,
                rating: rating,
                cover: item.subject?.images?.medium || "/assets/anime/default.webp",
                description: (
                    item.subject?.short_summary ||
                    item.subject?.name_cn ||
                    ""
                ).trimStart(),
                episodes: `${totalEpisodes} episodes`,
                year: year,
                genre: item.subject?.tags
                    ? item.subject.tags.slice(0, 3).map((tag: any) => tag.name)
                    : ["Unknown"],
                studio: studio,
                link: item.subject?.id
                    ? `https://bgm.tv/subject/${item.subject.id}`
                    : "#",
                progress: progress,
                totalEpisodes: totalEpisodes,
                startDate: item.subject?.date || "",
                endDate: item.subject?.date || "",
            } as AnimeItem;
        }),
    );
    return detailedItems as AnimeItem[];
}

// æ ¹æ®æ¨¡å¼è·å–ç•ªå‰§åˆ—è¡¨
let animeList: AnimeItem[] = [];
if (ANIME_MODE === "local") {
    // ä½¿ç”¨æœ¬åœ°é…ç½®
    animeList = localAnimeList as AnimeItem[];
} else {
    // ä½¿ç”¨Bangumi APIï¼ˆé»˜è®¤æ¨¡å¼ï¼‰
    // è·å–ä¸å¤„ç†åœ¨çœ‹åˆ—è¡¨ï¼ˆtype=3ï¼‰æƒ³çœ‹åˆ—è¡¨ï¼ˆtype=1ï¼‰çœ‹è¿‡åˆ—è¡¨ï¼ˆtype=2ï¼‰æç½®åˆ—è¡¨ï¼ˆtype=4ï¼‰æŠ›å¼ƒåˆ—è¡¨ï¼ˆtype=5ï¼‰
    const watchingData = await fetchBangumiCollection(BANGUMI_USER_ID, 2, 3);
    const plannedData = await fetchBangumiCollection(BANGUMI_USER_ID, 2, 1);
    const completedData = await fetchBangumiCollection(BANGUMI_USER_ID, 2, 2);
    const onHoldData = await fetchBangumiCollection(BANGUMI_USER_ID, 2, 4);
    const droppedData = await fetchBangumiCollection(BANGUMI_USER_ID, 2, 5);

    const watchingList = watchingData
        ? await processBangumiData(watchingData, "watching")
        : [];
    const plannedList = plannedData
        ? await processBangumiData(plannedData, "planned")
        : [];
    const completedList = completedData
        ? await processBangumiData(completedData, "completed")
        : [];
    const onHoldList = onHoldData
        ? await processBangumiData(onHoldData, "onhold")
        : [];
    const droppedList = droppedData
        ? await processBangumiData(droppedData, "dropped")
        : [];

    animeList = [
        ...watchingList,
        ...plannedList,
        ...completedList,
        ...onHoldList,
        ...droppedList,
    ];
}

// è·å–çŠ¶æ€çš„ç¿»è¯‘æ–‡æœ¬å’Œæ ·å¼
function getStatusInfo(status: string) {
    switch (status) {
        case "watching":
            return {
                text: i18n(I18nKey.animeStatusWatching),
                class:
                    "bg-green-100 text-green-700 dark:bg-green-900/30 dark:text-green-300",
                icon: "â–¶",
            };
        case "completed":
            return {
                text: i18n(I18nKey.animeStatusCompleted),
                class:
                    "bg-blue-100 text-blue-700 dark:bg-blue-900/30 dark:text-blue-300",
                icon: "âœ“",
            };
        case "planned":
            return {
                text: i18n(I18nKey.animeStatusPlanned),
                class:
                    "bg-amber-100 text-amber-700 dark:bg-amber-900/30 dark:text-amber-300",
                icon: "â°",
            };
        case "onhold":
            return {
                text: i18n(I18nKey.animeStatusOnHold),
                class:
                    "bg-purple-100 text-purple-700 dark:bg-purple-900/30 dark:text-purple-300",
                icon: "â¸",
            };
        case "dropped":
            return {
                text: i18n(I18nKey.animeStatusDropped),
                class: "bg-red-100 text-red-700 dark:bg-red-900/30 dark:text-red-300",
                icon: "âœ—",
            };
        default:
            return {
                text: status,
                class: "bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300",
                icon: "?",
            };
    }
}

// è®¡ç®—ç»Ÿè®¡æ•°æ®
const stats = {
    total: animeList.length,
    watching: animeList.filter((anime) => anime.status === "watching").length,
    completed: animeList.filter((anime) => anime.status === "completed").length,
    avgRating: (() => {
        const ratedAnime = animeList.filter((anime) => anime.rating > 0);
        if (ratedAnime.length === 0) return "0.0";
        return (
            ratedAnime.reduce((sum, anime) => sum + anime.rating, 0) /
            ratedAnime.length
        ).toFixed(1);
    })(),
};

// è·å–æœ€åä¿®æ”¹æ—¶é—´ï¼ˆå½“å‰æ—¶é—´ï¼Œä½¿ç”¨åŒ—äº¬æ—¶é—´ï¼‰
const lastUpdated = new Date().toLocaleString('zh-CN', {
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    hour12: false,
    timeZone: 'Asia/Shanghai'
});

// æŒ‰æœ€åä¿®æ”¹æ—¶é—´æ’åºï¼ˆå‡è®¾Bangumiæ•°æ®æœ‰æ›´æ–°æ—¶é—´ï¼‰
const sortedAnimeList = [...animeList].sort((a, b) => {
    if (a.endDate && b.endDate) {
        return new Date(b.endDate).getTime() - new Date(a.endDate).getTime();
    }
    return 0;
});
---

<MainGridLayout title={i18n(I18nKey.anime)} description={i18n(I18nKey.animeSubtitle)}>
  <div class="flex w-full rounded-[var(--radius-large)] overflow-hidden relative min-h-32">
    <div class="card-base z-10 px-9 py-6 relative w-full">
      <!-- é¡µé¢æ ‡é¢˜ -->
      <div class="relative w-full mb-8">
        <div class="mb-6">
          <h1 class="text-4xl font-bold text-black/90 dark:text-white/90 mb-2 relative
                    before:w-1 before:h-8 before:rounded-md before:bg-[var(--primary)]
                    before:absolute before:top-1/2 before:-translate-y-1/2 before:-left-4">
            {i18n(I18nKey.animeTitle)}
          </h1>
          <p class="text-black/75 dark:text-white/75">{i18n(I18nKey.animeSubtitle)}</p>
        </div>
        
        <!-- ç»Ÿè®¡ä¿¡æ¯å¡ç‰‡ -->
        <div class="stats-container grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
          <div class="stat-card bg-[var(--card-bg)] border border-[var(--line-divider)] rounded-[var(--radius-large)] p-4 flex flex-col items-center justify-center">
            <div class="text-xs text-black/60 dark:text-white/60 mb-1">æ€»æ•°</div>
            <div class="text-2xl font-bold text-[var(--primary)]">{stats.total}</div>
          </div>
          <div class="stat-card bg-[var(--card-bg)] border border-[var(--line-divider)] rounded-[var(--radius-large)] p-4 flex flex-col items-center justify-center">
            <div class="text-xs text-black/60 dark:text-white/60 mb-1">ç»¼åˆè¯„åˆ†</div>
            <div class="text-2xl font-bold text-blue-500">{stats.avgRating}</div>
          </div>
          <div class="stat-card bg-[var(--card-bg)] border border-[var(--line-divider)] rounded-[var(--radius-large)] p-4 flex flex-col items-center justifyä¸­å¿ƒ">
            <div class="text-xs text-black/60 dark:text-white/60 mb-1">æœ€åæ›´æ–°æ—¶é—´</div>
            <div class="text-sm font-medium texté»‘/80 dark:textç™½/80">{lastUpdated}</div>
          </div>
        </div>
        
        <!-- æœç´¢æ¡† -->
        <div class="search-container mb-6">
          <div class="relative">
            <input 
              type="text" 
              id="search-input" 
              placeholder="æœç´¢ç•ªå‰§åç§°ã€ç±»å‹ã€åˆ¶ä½œæ–¹..."
              class="w-full px-4 py-3 pl-12 rounded-[var(--radius-large)] border border-[var(--line-divider)] bg-[var(--card-bg)] text-[var(--text-body)] focus:outline-none focus:ring-2 focus:ring-[var(--primary)] focus:border-transparent"
            />
            <div class="absolute left-4 top-1/2 transform -translate-y-1/2 text-[var(--text-secondary)]">
              <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
              </svg>
            </div>
          </div>
        </div>
        
        <!-- è¿‡æ»¤æŒ‰é’® - å‚è€ƒFireflyè®¾è®¡ -->
        <div class="mb-6">
          <div class="filter-container flex flex-wrap gap-2">
            <button class="filter-tag active" data-status="all">
              {i18n(I18nKey.animeFilterAll)} 
              <span class="ml-1 bg-[var(--primary)] text-white text-xs rounded-full px-2 py-0.5">({animeList.length})</span>
            </button>
            <button class="filter-tag" data-status="watching">
              {i18n(I18nKey.animeStatusWatching)} 
              <span class="ml-1 bg-green-500 text-white text-xs rounded-full px-2 py-0.5">({animeList.filter(a => a.status === 'watching').length})</span>
            </button>
            <button class="filter-tag" data-status="planned">
              {i18n(I18nKey.animeStatusPlanned)} 
              <span class="ml-1 bg-amber-500 text-white text-xs rounded-full px-2 py-0.5">({animeList.filter(a => a.status === 'planned').length})</span>
            </button>
            <button class="filter-tag" data-status="completed">
              {i18n(I18nKey.animeStatusCompleted)} 
              <span class="ml-1 bg-blue-500 text-white text-xs rounded-full px-2 py-0.5">({animeList.filter(a => a.status === 'completed').length})</span>
            </button>
            {ANIME_MODE === 'bangumi' && (
              <>
                <button class="filter-tag" data-status="onhold">
                  {i18n(I18nKey.animeStatusOnHold)} 
                  <span class="ml-1 bg-purple-500 text-white text-xs rounded-full px-2 py-0.5">({animeList.filter(a => a.status === 'onhold').length})</span>
                </button>
                <button class="filter-tag" data-status="dropped">
                  {i18n(I18nKey.animeStatusDropped)} 
                  <span class="ml-1 bg-red-500 text-white text-xs rounded-full px-2 py-0.5">({animeList.filter(a => a.status === 'dropped').length})</span>
                </button>
              </>
            )}
          </div>
        </div>
      </div>

      <!-- åŠ¨æ¼«åˆ—è¡¨ -->
      <div class="mb-8">
        
        {ANIME_MODE !== 'local' && BANGUMI_USER_ID === 'your-user-id' ? (
          <div class="text-center py-12">
            <div class="text-5xl mb-4">ğŸ˜¢</div>
            <h3 class="text-xl font-medium texté»‘/80 dark:textç™½/80 mb-2">
              {i18n(I18nKey.animeEmpty)}
            </h3>
            <p class="texté»‘/60 dark:textç™½/60">
              è¯·åœ¨ src/config.ts æ–‡ä»¶ä¸­è®¾ç½®ä½ çš„ Bangumi ç”¨æˆ·ID
            </p>
          </div>
        ) : animeList.length > 0 ? (
          <div id="anime-list-container" class={`anime-grid-container grid gap-4 md:gap-6 list-mode ${
            isBothSidebarMode 
              ? "both-sidebar" 
              : "single-sidebar"
          }`}>
            {sortedAnimeList.map(anime => {
              const statusInfo = getStatusInfo(anime.status);
              const progressPercent = anime.totalEpisodes > 0 ? (anime.progress / anime.totalEpisodes) * 100 : 0;
              
              return (
                <div class="group relative bg-[var(--card-bg)] border border-[var(--line-divider)] rounded-[var(--radius-large)] overflow-hidden transition-all duration-300 hover:shadow-lg hover:scale-[1.02]" data-anime-status={anime.status} data-anime-title={anime.title.toLowerCase()} data-anime-studio={anime.studio.toLowerCase()} data-anime-genre={anime.genre.map(g => g.toLowerCase()).join(' ')}>
                  <!-- å°é¢åŒºåŸŸ - ç«–å±æ¯”ä¾‹ -->
                  <div class="relative aspect-[2/3] overflow-hidden">
                    <a href={anime.link} target="_blank" rel="noopener noreferrer" class="block w-full h-full">
                      <ImageWrapper 
                        src={anime.cover} 
                        alt={anime.title}
                        class="w-full h-full object-cover transition-transform duration-300 group-hover:scale-110"
                      />
                      <div class="absolute inset-0 bg-gradient-to-t fromé»‘/60 via-transparent to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300">
                        <div class="absolute inset-0 flex itemsä¸­å¿ƒ justify-center">
                          <div class="w-12 h-12 rounded-full bgç™½/90 flex items-center justify-center">
                            <svg class="w-6 h-6 textç°-800 ml-1" fill="currentColor" viewBox="0 0 24 24">
                              <path d="M8 5v14l11-7z"/>
                            </svg>
                          </div>
                        </div>
                      </div>
                    </a>
                    
                    <!-- çŠ¶æ€æ ‡ç­¾ -->
                    <div class={`absolute top-2 left-2 px-2 py-1 rounded-md text-xs font-medium ${statusInfo.class}`}>
                      <span class="mr-1">{statusInfo.icon}</span>
                      <span>{statusInfo.text}</span>
                    </div>
                    
                    <!-- è¯„åˆ†å°æ–¹æ¡† -->
                    <div class="absolute top-2 right-2">
                      <div class="bg-black/70 text-white rounded-[6px] border border-white/20 shadow-sm inline-flex items-center gap-1 px-2 py-1">
                        <svg class="w-4 h-4 text-yellow-400" fill="currentColor" viewBox="0 0 20 20" aria-hidden="true">
                          <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l-1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"/>
                        </svg>
                        <span class="text-[10px] font-semibold leading-none">{anime.rating}</span>
                      </div>
                    </div>
                    
                    <!-- è¿›åº¦æ¡ -->
                    {anime.status === 'watching' && (
                      <div class="absolute bottom-0 left-0 right-0 bg-gradient-to-t fromé»‘/80 to-transparent p-2">
                        <div class="w-full bgç™½/20 rounded-full h-1.5 mb-1">
                          <div class="bg-gradient-to-r from-emerald-400 to-teal-400 h-1.5 rounded-full transition-all duration-300" style={`width: ${progressPercent}%`}></div>
                        </div>
                        <div class="textç™½ text-xs font-medium">
                          {anime.progress}/{anime.totalEpisodes} ({Math.round(progressPercent)}%)
                        </div>
                      </div>
                    )}
                  </div>
                  
                  <!-- å†…å®¹åŒºåŸŸ -->
                  <div class="p-3">
                    <h3 class="text-sm font-bold texté»‘/90 dark:textç™½/90 mb-1 line-clamp-2 leading-tight">{anime.title}</h3>
                    <p class="texté»‘/60 dark:textç™½/60 text-xs mb-2 line-clamp-2">{anime.description}</p>
                    
                    <div class="space-y-1 text-xs">
                      <div class="flex justify-between">
                        <span class="texté»‘/50 dark:textç™½/50">{i18n(I18nKey.animeYear)}</span>
                        <span class="texté»‘/70 dark:textç™½/70">{anime.year}</span>
                      </div>
                      <div class="flex justifyä¹‹é—´">
                        <span class="texté»‘/50 dark:textç™½/50">{i18n(I18nKey.animeStudio)}</span>
                        <span class="texté»‘/70 dark:textç™½/70 truncate ml-2">{anime.studio}</span>
                      </div>
                      <div class="flex flex-wrap gap-1 mt-2">
                        {anime.genre.map(g => (
                          <span class="px-1.5 py-0.5 bg-[var(--btn-regular-bg)] texté»‘/70 dark:textç™½/70 rounded text-xs">{g}</span>
                        ))}
                      </div>
                    </div>
                  </div>
                </div>
              );
            })}
          </div>
        ) : (
          <div class="text-center py-12">
            <div class="text-5xl mb-4">ğŸ˜¢</div>
            <h3 class="text-xl font-medium texté»‘/80 dark:textç™½/80 mb-2">
              {i18n(I18nKey.animeEmpty)}
            </h3>
            <p class="texté»‘/60 dark:textç™½/60">
              {ANIME_MODE === 'local' ? i18n(I18nKey.animeEmptyLocal) : i18n(I18nKey.animeEmptyBangumi)}
            </p>
          </div>
        )}
      </div>
      
      <!-- åˆ†é¡µæ§ä»¶ -->
      <div id="pagination-container" class="pagination-container flex justify-center items-center gap-2 mt-8">
        <button id="prev-page" class="pagination-btn px-3 py-2 rounded-md bg-[var(--btn-regular-bg)] text-[var(--btn-content)] border border-[var(--line-divider)] disabled:opacity-50 disabled:cursor-not-allowed">
          &lt; {i18n(I18nKey.prevPage)}
        </button>
        <div id="page-numbers" class="flex gap-1"></div>
        <button id="next-page" class="pagination-btn px-3 py-2 rounded-md bg-[var(--btn-regular-bg)] text-[var(--btn-content)] border border-[var(--line-divider)] disabled:opacity-50 disabled:cursor-not-allowed">
          {i18n(I18nKey.nextPage)} &gt;
        </button>
      </div>
    </div>
  </div>

  <script is:inline define:vars={{ isBothSidebarMode }}>
  // åŠ¨ç”»åˆ—è¡¨å¸ƒå±€åˆ‡æ¢è„šæœ¬ï¼ˆä¿æŒåŸé€»è¾‘ï¼‰
  (function() {
    setTimeout(() => {
      const animeListContainer = document.getElementById("anime-list-container");
      if (!animeListContainer) {
        console.debug("anime-list-container not found, skipping layout initialization");
        return;
      }

      if (typeof window.layoutManager !== 'undefined') {
        window.layoutManager.init(isBothSidebarMode);
        const currentLayout = window.layoutManager.getLayout();
        updateAnimeListLayout(currentLayout);
        window.layoutManager.checkScreenSizeAndAdjust();
      } else {
        setTimeout(() => {
          if (typeof window.layoutManager !== 'undefined') {
            window.layoutManager.init(isBothSidebarMode);
            const currentLayout = window.layoutManager.getLayout();
            updateAnimeListLayout(currentLayout);
            window.layoutManager.checkScreenSizeAndAdjust();
          }
        }, 300);
      }
    }, 50);

    function updateAnimeListLayout(layout) {
      const animeListContainer = document.getElementById("anime-list-container");
      if (!animeListContainer) return;

      // First
      const animeItems = Array.from(document.querySelectorAll('[data-anime-status]'));
      const firstPositions = new Map();
      animeItems.forEach(item => {
        const rect = item.getBoundingClientRect();
        firstPositions.set(item, { left: rect.left, top: rect.top, width: rect.width, height: rect.height });
      });
      
      // åˆ‡æ¢å¸ƒå±€ç±»
      animeListContainer.classList.remove("list-mode", "grid-mode");
      if (layout === "grid") {
        animeListContainer.classList.add("grid-mode");
        animeListContainer.classList.add("grid", "grid-cols-1", "md:grid-cols-2", "lg:grid-cols-3");
        animeListContainer.classList.remove("flex", "flex-col");
        const rightSidebar = document.querySelector('.right-sidebar-container');
        if (rightSidebar) { rightSidebar.style.display = 'none'; rightSidebar.classList.add('hidden-in-grid-mode'); }
        const mainGrid = document.getElementById('main-grid');
        if (mainGrid) { mainGrid.style.gridTemplateColumns = '17.5rem 1fr'; mainGrid.classList.add('two-column-layout'); mainGrid.setAttribute('data-layout-mode', 'grid'); }
      } else {
        animeListContainer.classList.add("list-mode");
        animeListContainer.classList.add("flex", "flex-col");
        animeListContainer.classList.remove("grid", "grid-cols-1", "md:grid-cols-2", "lg:grid-cols-3");
        const rightSidebar = document.querySelector('.right-sidebar-container');
        if (rightSidebar) { rightSidebar.style.display = ''; rightSidebar.classList.remove('hidden-in-grid-mode'); }
        const mainGrid = document.getElementById('main-grid');
        if (mainGrid) { mainGrid.style.gridTemplateColumns = ''; mainGrid.classList.remove('two-column-layout'); mainGrid.setAttribute('data-layout-mode', 'list'); }
      }

      // Last + Invert
      requestAnimationFrame(() => {
        const lastPositions = new Map();
        animeItems.forEach(item => {
          const rect = item.getBoundingClientRect();
          lastPositions.set(item, { left: rect.left, top: rect.top });
        });
        
        animeItems.forEach(item => {
          const first = firstPositions.get(item);
          const last = lastPositions.get(item);
          if (first && last) {
            const dx = first.left - last.left;
            const dy = first.top - last.top;
            item.style.transition = 'none';
            item.style.transform = `translate(${dx}px, ${dy}px)`;
          }
        });

        // Play
        requestAnimationFrame(() => {
          animeItems.forEach((item, index) => {
            setTimeout(() => {
              item.classList.add('anime-animating');
              item.style.transition = '';
              item.style.transform = '';
            }, index * 20);
          });
          setTimeout(() => {
            animeItems.forEach(item => {
              item.classList.remove('anime-animating');
              item.style.transition = '';
              item.style.transform = '';
            });
          }, 500 + animeItems.length * 20);
        });
      });
    }

    window.addEventListener("layoutChange", (event) => {
      updateAnimeListLayout(event.detail.layout);
    });
  })();
</script>

<!-- æ ·å¼ï¼ˆä¿æŒåŸæ ·ï¼‰ -->
  <style>
    :root {
      --anime-font: 'Comic Sans MS', 'Chalkboard SE', 'Marker Felt', system-ui, -apple-system, 'Segoe UI', Roboto, 'Noto Sans SC', 'Segoe UI Emoji', 'Apple Color Emoji', sans-serif;
    }
    html.dark {
      --anime-font: 'Noto Sans SC', 'Hiragino Sans GB', 'PingFang SC', 'Microsoft YaHei UI', system-ui, -apple-system, 'Segoe UI', Roboto, 'Segoe UI Emoji', 'Apple Color Emoji', sans-serif;
    }
    body, h1, h2, h3, h4, h5, h6, p, span, div, button, input, textarea, select, a {
      font-family: var(--anime-font) !important;
    }
    
    .card-base { container-type: inline-size; }
    
    .anime-grid-container {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .anime-grid-container.single-sidebar {
      @container (min-width: 900px) { grid-template-columns: repeat(5, 1fr); }
      @container (min-width: 600px) and (max-width: 899px) { grid-template-columns: repeat(3, 1fr); }
      @container (max-width: 599px) { grid-template-columns: repeat(2, 1fr); }
    }
    
    .anime-grid-container.both-sidebar {
      @container (min-width: 950px) { grid-template-columns: repeat(5, 1fr); }
      @container (min-width: 650px) and (max-width: 949px) { grid-template-columns: repeat(4, 1fr); }
      @container (min-width: 480px) and (max-width: 649px) { grid-template-columns: repeat(3, 1fr); }
      @container (max-width: 479px) { grid-template-columns: repeat(2, 1fr); }
    }
    
    .filter-container { display: flex; flex-wrap: wrap; gap: 0.5rem; }
    .filter-tag {
      padding: 0.5rem 1rem; border: 1px solid var(--line-divider); border-radius: var(--radius-large);
      background: var(--btn-regular-bg); color: var(--btn-content);
      font-size: 0.875rem; font-weight: 500; cursor: pointer; transition: all 0.2s ease; white-space: nowrap; display: flex; align-items: center;
    }
    .filter-tag:hover:not(.active) { background: var(--btn-hover-bg); border-color: var(--primary); transform: translateY(-1px); }
    .filter-tag.active { background: var(--primary); color: white; border-color: var(--primary); }
    .filter-tag.active:hover { background: var(--primary) !important; color: white !é‡è¦; border-color: var(--primary) !important; transform: translateY(-1px); }
    
    [data-anime-status] { transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1); }
    #anime-list-container.grid-mode [data-anime-status]:hover {
      transform: translateY(-8px) scale(1.02);
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.15);
      z-index: 10; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    #anime-list-container.list-mode [data-anime-status]:hover {
      transform: translateX(8px) scale(1.01);
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
      z-index: 10; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    [data-anime-status].anime-hidden { display: none; }
    [data-anime-status].anime-animating {
      transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    }
    [data-anime-status].anime-fade-in { opacity: 0; transform: scale(0.8); }
    [data-anime-status].anime-fade-in-active { opacity: 1; transform: scale(1); }
    
    .stats-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; }
    .stat-card { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 1rem; text-align: center; }
    
    .pagination-container { margin-top: 2rem; display: flex; justify-center: center; align-items: center; gap: 0.5rem; }
    .pagination-btn {
      padding: 0.5rem 1rem; border: 1px solid var(--line-divider); border-radius: var(--radius-large);
      background: var(--btn-regular-bg); color: var(--btn-content);
      font-size: 0.875rem; font-weight: 500; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; gap: 0.25rem;
    }
    .pagination-btn:hover:not(:disabled) { background: var(--btn-hover-bg); border-color: var(--primary); transform: translateY(-1px); }
    .pagination-btn:disabled { opacity: 0.5; cursor: not-allowed; }
    
    .page-number {
      padding: 0.5rem 0.75rem; border: 1px solid var(--line-divider); border-radius: var(--radius-large);
      background: var(--btn-regular-bg); color: var(--btn-content);
      font-size: 0.875rem; font-weight: 500; cursor: pointer; transition: all 0.2s ease;
    }
    .page-number:hover { background: var(--btn-hover-bg); border-color: var(--primary); }
    .page-number.active { background: var(--primary); color: white; border-color: var(--primary); }
    
    .search-container { position: relative; margin-bottom: 1.5rem; }
    #search-input { padding-left: 2.5rem; transition: all 0.3s ease; }
    #search-input:focus { box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2); }
    .search-highlight { background-color: #fef3c7; padding: 0.125rem 0.25rem; border-radius: 0.25rem; font-weight: 600; }
  </style>

  <!-- è¿‡æ»¤åŠŸèƒ½ + åˆ†é¡µä¿®å¤ï¼ˆåŠ¨æ•ˆä¿æŒä¸å˜ï¼‰ -->
  <script is:inline>
    // é˜²é‡å¤ç»‘å®šå­˜å‚¨
    if (typeof window.animeFilterEventListeners === 'undefined') {
      window.animeFilterEventListeners = [];
    }
    
    // åˆ†é¡µçŠ¶æ€
    let currentPage = 1;
    const itemsPerPage = 12;
    let filteredItems = Array.from(document.querySelectorAll('[data-anime-status]'));

    function updatePagination() {
      const totalPages = Math.ceil(filteredItems.length / itemsPerPage);
      const pageNumbersContainer = document.getElementById('page-numbers');
      if (!pageNumbersContainer) return;
      pageNumbersContainer.innerHTML = '';
      
      for (let i = 1; i <= totalPages; i++) {
        const pageNum = document.createElement('button');
        pageNum.textContent = i;
        pageNum.classList.add('page-number');
        if (i === currentPage) pageNum.classList.add('active');
        pageNum.addEventListener('click', () => {
          currentPage = i;
          showPage(currentPage);
          updatePagination();
        });
        pageNumbersContainer.appendChild(pageNum);
      }
      
      const prevBtn = document.getElementById('prev-page');
      const nextBtn = document.getElementById('next-page');
      if (prevBtn && nextBtn) {
        prevBtn.disabled = currentPage === 1;
        nextBtn.disabled = currentPage === totalPages || totalPages === 0;
      }
    }
    
    function showPage(page) {
      const startIndex = (page - 1) * itemsPerPage;
      const endIndex = startIndex + itemsPerPage;
      const itemsToShow = filteredItems.slice(startIndex, endIndex);
      
      document.querySelectorAll('[data-anime-status]').forEach(item => {
        item.style.display = 'none';
      });
      itemsToShow.forEach(item => {
        item.style.display = 'block';
      });
    }

    // åŸºäºå½“å‰å¯è§é›†åˆé‡å»ºåˆ†é¡µï¼ˆå…³é”®ä¿®å¤ï¼‰
    function rebuildPaginationFromVisibility() {
      const allItems = Array.from(document.querySelectorAll('[data-anime-status]'));
      // ä»…ç»Ÿè®¡æœªè¢« anime-hidden éšè—çš„é¡¹ï¼ˆè¿‡æ»¤ä¸æœç´¢çš„æœ€ç»ˆå¯è§é›†åˆï¼‰
      filteredItems = allItems.filter(item => !item.classList.contains('anime-hidden'));
      currentPage = 1;
      showPage(currentPage);
      updatePagination();
    }

    // åˆå§‹åŒ–è¿‡æ»¤åŠŸèƒ½ï¼ˆä¿æŒä½ åŸæœ‰çš„ FLIP åŠ¨æ•ˆï¼‰
    function initFilterButtons() {
      const filterTags = document.querySelectorAll('.filter-tag');
      
      // æ¸…ç†æ—§ç›‘å¬
      window.animeFilterEventListeners.forEach(listener => {
        const [element, type, handler] = listener;
        element.removeEventListener(type, handler);
      });
      window.animeFilterEventListeners = [];
      
      filterTags.forEach(tag => {
        const clickHandler = function() {
          if (this.classList.contains('active')) return;
          filterTags.forEach(t => t.classList.remove('active'));
          this.classList.add('active');
          
          const status = this.getAttribute('data-status');
          const animeItems = Array.from(document.querySelectorAll('[data-anime-status]'));
          
          // First
          const firstPositions = new Map();
          animeItems.forEach(item => {
            const rect = item.getBoundingClientRect();
            firstPositions.set(item, {
              left: rect.left,
              top: rect.top,
              width: rect.width,
              height: rect.height
            });
          });
          
          const itemsToHide = [];
          const itemsToShow = [];
          const itemsToKeep = [];
          
          animeItems.forEach(item => {
            const itemStatus = item.getAttribute('data-anime-status');
            const shouldShow = status === 'all' || itemStatus === status;
            const isCurrentlyVisible = !item.classList.contains('anime-hidden');
            
            if (shouldShow) {
              if (isCurrentlyVisible) itemsToKeep.push(item);
              else itemsToShow.push(item);
            } else {
              if (isCurrentlyVisible) itemsToHide.push(item);
            }
          });
          
          // æ·¡å‡º
          itemsToHide.forEach(item => {
            item.classList.add('anime-fade-out');
          });
          
          setTimeout(() => {
            // çœŸæ­£éšè—
            itemsToHide.forEach(item => {
              item.classList.add('anime-hidden');
              item.classList.remove('anime-fade-out');
            });
            
            // æ–°æ˜¾ç¤ºï¼šå…ˆé€æ˜ç¼©å°
            itemsToShow.forEach(item => {
              item.classList.remove('anime-hidden');
              item.classList.add('anime-fade-in');
              item.style.opacity = '0';
              item.style.transform = 'scale(0.8)';
              item.style.transition = 'none';
            });
            
            // Last
            requestAnimationFrame(() => {
              const lastPositions = new Map();
              [...itemsToKeep, ...itemsToShow].forEach(item => {
                const rect = item.getBoundingClientRect();
                lastPositions.set(item, { left: rect.left, top: rect.top });
              });
              
              // Invert
              itemsToKeep.forEach(item => {
                const first = firstPositions.get(item);
                const last = lastPositions.get(item);
                if (first && last) {
                  const deltaX = first.left - last.left;
                  const deltaY = first.top - last.top;
                  item.style.transition = 'none';
                  item.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                }
              });
              
              // Play
              requestAnimationFrame(() => {
                const allItems = [...itemsToKeep, ...itemsToShow];
                
                allItems.forEach((item, index) => {
                  setTimeout(() => {
                    item.classList.add('anime-animating');
                    if (itemsToKeep.includes(item)) {
                      item.style.transition = '';
                      item.style.transform = '';
                    }
                    if (itemsToShow.includes(item)) {
                      item.classList.remove('anime-fade-in');
                      item.classList.add('anime-fade-in-active');
                      item.style.transition = '';
                      item.style.opacity = '1';
                      item.style.transform = 'scale(1)';
                    }
                  }, index * 20);
                });
                
                // åŠ¨ç”»å®Œæˆåæ¸…ç† + é‡å»ºåˆ†é¡µï¼ˆå…³é”®ä¿®å¤ï¼‰
                setTimeout(() => {
                  allItems.forEach(item => {
                    item.classList.remove('anime-animating', 'anime-fade-in-active');
                    item.style.transition = '';
                    item.style.transform = '';
                    item.style.opacity = '';
                  });
                  rebuildPaginationFromVisibility();
                }, 500 + allItems.length * 20);
              });
            });
          }, 300);
        };
        
        tag.addEventListener('click', clickHandler);
        window.animeFilterEventListeners.push([tag, 'click', clickHandler]);
      });
      
      console.log('Filter buttons initialized with', filterTags.length, 'buttons');
    }
    
    // æœç´¢åŠŸèƒ½ï¼ˆä¿æŒåŸé€»è¾‘ï¼Œç»“å°¾ç»Ÿä¸€é‡å»ºåˆ†é¡µï¼‰
    function searchAnime(searchTerm) {
      const allItems = Array.from(document.querySelectorAll('[data-anime-status]'));
      const matched = [];
      
      if (!searchTerm.trim()) {
        allItems.forEach(item => {
          item.style.display = 'block';
          item.classList.remove('anime-hidden');
        });
        return allItems;
      }
      
      const q = searchTerm.toLowerCase();
      allItems.forEach(item => {
        const title = item.getAttribute('data-anime-title') || '';
        const studio = item.getAttribute('data-anime-studio') || '';
        const genre = item.getAttribute('data-anime-genre') || '';
        const status = item.getAttribute('data-anime-status') || '';
        const ok = title.includes(q) || studio.includes(q) || genre.includes(q) || status.includes(q);
        if (ok) {
          item.style.display = 'block';
          item.classList.remove('anime-hidden');
          matched.push(item);
        } else {
          item.style.display = 'none';
          item.classList.add('anime-hidden');
        }
      });
      return matched;
    }
    
    // åˆå§‹åŒ–ï¼ˆé¦–æ¬¡è¿›å…¥ + Swupï¼‰
    function initAnimePage() {
      const container = document.getElementById('anime-list-container');
      const pagination = document.getElementById('pagination-container');
      if (!container || !pagination) {
        // ç­‰å¾…ä¸‹ä¸€å¸§ï¼Œé¿å…èŠ‚ç‚¹æœªæ¸²æŸ“å¯¼è‡´çš„â€œåˆ†é¡µä¸æ˜¾ç¤ºâ€
        requestAnimationFrame(() => requestAnimationFrame(initAnimePage));
        return;
      }

      initFilterButtons();

      // åˆå§‹æŒ‰å½“å‰æ¿€æ´»è¿‡æ»¤å™¨æ˜¾ç¤ºç¬¬ 1 é¡µ
      // ç”±äºåˆå§‹æ²¡æœ‰ anime-hiddenï¼Œç›´æ¥ä»å…¨éƒ¨å¯è§é¡¹é‡å»ºåˆ†é¡µ
      rebuildPaginationFromVisibility();

      // ç»‘å®šç¿»é¡µæŒ‰é’®ï¼ˆé˜²é‡å¤ï¼‰
      const prevBtn = document.getElementById('prev-page');
      const nextBtn = document.getElementById('next-page');
      if (prevBtn && !prevBtn.__bound) {
        prevBtn.addEventListener('click', () => {
          if (currentPage > 1) {
            currentPage--;
            showPage(currentPage);
            updatePagination();
          }
        });
        prevBtn.__bound = true;
      }
      if (nextBtn && !nextBtn.__bound) {
        nextBtn.addEventListener('click', () => {
          const totalPages = Math.ceil(filteredItems.length / itemsPerPage);
          if (currentPage < totalPages) {
            currentPage++;
            showPage(currentPage);
            updatePagination();
          }
        });
        nextBtn.__bound = true;
      }
      
      // æœç´¢ï¼ˆé˜²æŠ– + æ¿€æ´»è¿‡æ»¤å åŠ ï¼‰
      const searchInput = document.getElementById('search-input');
      if (searchInput && !searchInput.__bound) {
        let searchTimeout;
        searchInput.addEventListener('input', function() {
          clearTimeout(searchTimeout);
          searchTimeout = setTimeout(() => {
            const results = searchAnime(this.value);
            // è‹¥æœ‰æ¿€æ´»çš„è¿‡æ»¤å™¨ï¼Œå åŠ çŠ¶æ€é™åˆ¶
            const activeFilterBtn = document.querySelector('.filter-tag.active');
            const activeStatus = activeFilterBtn ? activeFilterBtn.getAttribute('data-status') : 'all';
            if (activeStatus !== 'all') {
              results.forEach(item => {
                const s = item.getAttribute('data-anime-status');
                if (s !== activeStatus) {
                  item.style.display = 'none';
                  item.classList.add('anime-hidden');
                }
              });
            }
            // ç»Ÿä¸€åŸºäºå¯è§é¡¹é‡å»ºåˆ†é¡µï¼Œæ˜¾ç¤ºç¬¬ 1 é¡µ
            rebuildPaginationFromVisibility();
          }, 300);
        });
        searchInput.__bound = true;
      }
    }
    
    // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–ï¼ˆåŒ rAFï¼‰
    document.addEventListener('DOMContentLoaded', () => {
      requestAnimationFrame(() => requestAnimationFrame(initAnimePage));
    });
    
    // Swupé¡µé¢åˆ‡æ¢åé‡æ–°åˆå§‹åŒ–ï¼ˆä¿æŒè½»é‡ï¼‰
    function setupSwupListeners() {
      if (window.swup) {
        const reinit = () => requestAnimationFrame(() => setTimeout(initAnimePage, 60));
        window.swup.hooks.on('content:replace', reinit);
        window.swup.hooks.on('page:view', reinit);
        window.swup.hooks.on('animation:in:end', reinit);
      }
    }
    if (typeof window !== 'undefined') {
      if (window.swup) {
        setupSwupListeners();
      } else {
        document.addEventListener('swup:enable', setupSwupListeners);
      }
    }
  </script>
</MainGridLayout>
